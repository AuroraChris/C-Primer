// 要注意，当我们将一个类的对象当作实参传入一个函数时，将触发的是拷贝构造函数
// 而不是拷贝赋值函数，如：
// void func(T a){}
// T b;
// func(b); -> 会触发T的拷贝构造函数而不是拷贝赋值函数，因为形参a提前并不
// 存在，只是当b传入时被拷贝构造了一个新的临时的函数局部变量a

// 前置递增、递减运算符会返回一个左值，而后置递增、递减运算法是返回一个右值

// unique_prt不能被拷贝，但有一个例外，那就是即将要被销毁的unique_ptr是
// 可以被拷贝或销毁的（这里的拷贝其实是触发了“移动构造函数”进行了移动）

// 如果一个成员函数有引用限定符，则具有相同参数列表的所有同名版本都应该具有
// 引用限定符，如：
// class Foo {
//     Foo sorted() &&;
//     Foo sorted() const;  错误，应该改成 Foo sorted() const &&
// }

// 对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数。
// 这一约定意味着当运算符作用于内置类型时，我们无法重载该运算符

// 我们只能重载已有的运算符，而无权发明新的运算符

// 如果我们希望为类自定义IO运算符，则必须将其定义成非成员函数，而且一般
// 会将它们声明成友元

// 我们可以为类定义从它转化为内置类型的“类型转换运算符”，有了这个运算符以后
// 我们可以像将内置类型隐式转化成类一样将类隐式转化为内置类型。我们同样可以
// 为了避免隐式转化将其定义为explicit。不过这个explicit有个例外，就是当
// 我们在一个表达式里运用了此种类到内置类型的转化，并且将这个表达式用在了条件
// 语句（if, while, for, !, ||, &&, ?:)中时，即使它是explicit的，编译器
// 依旧会将其认作是隐式的，顺利将其转化

// 关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义



