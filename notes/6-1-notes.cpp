// 使用关键字decltype的时候，如果表达式的求值结果是一个左值没那么decltype
// 作用于该表达式（不是变量）得到一个引用类型。如
// int *p, a = 10;
// p = &a;
// decltype(p) => int*
// decltype(*p) => int& 而不是 int

// 优先级规定了运算对象的组合方式，但没有说明运算对象按照什么顺序求值。如
// int i = f1() * f2(); 我们无法得知 f1 和 f2 谁先被调用
// cout << i << " " << ++i <<endl; 我们无法得知 ++i 是否会发生在
// 输出i之前，故有可能先输出i再++i，也有可能先++i再输出i

// 在最新的C++11标准里规定除法运算得到的结果一律向 0 取整（即直接切除
// 小数部分）

// 如果一条子表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话，
// 运算对象的求值顺序将会十分关键，如：
// *p = toupper(*p++);
// 这里赋值运算和 p++ 谁先进行对于编译器来说是未知的，编译器有可能如下处理
// *p = toupper(*p) or *(p+1) = toupper(*p);
// 又如：
// vec[i++] <= vec[i]; 对于编译器来说，可能如下处理
// vec[i] <= vec[i+1] or vec[i] <= vec[i]

// 函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针

// 函数内部的局部静态对象会在程序执行到该对象初始化语句时第一次被创建，并且
// 将会一直存在于函数内部，直到程序终止才被销毁。但我们依旧无法在函数外部
// 使用它，因为它仍然是一个函数内部的局部对象

