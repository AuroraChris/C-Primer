// C++中并没有定义两个迭代器的加法运算，因此将两个迭代器相加是非法的

/**
 * 数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。
 * 换句话说，维度必须是一个常量表达式。如被const或constexpr修饰的
 * 变量或函数等
 **/

// 我们可以用字符串字面值对数组进行初始化。当使用这种方式是，一定要注意
// 字符串字面值的结尾还有一个空字符，这个空字符也会像其他字符一样被拷贝
// 到字符数组中去

// 数组不允许拷贝和赋值（虽然有的编译器允许），但为了更好的扩展性应该尽量
// 避免这些操作

/**
 * 数组中元素的初始化也遵循类型初始化规则，即如int等内置类型。如果一个int
 * 类型的数组定义在所有函数体之外，那么数组中的所有int元素都将被默认输出化
 * 为0。但如果这个数组在函数体内（包括main函数），则里面的所有元素都会被初始
 * 化成一个奇异值
 **/

// 对于数组用auto推断类型往往得到的是指向数组首元素的指针类型，但用decltype
// 会得到正确的数组类型（包含数组容量，因为容量是数组类型里不可缺的一部分）。
// 但要注意，如果仅仅直接使用数组名字，它是不会自动转化为指向数组首元素的指针的，如
// int arr[10];
// ++arr; 非法，因为arr此时的类型依旧为 int[10]
// int *p = arr;
// ++p; 合法，此时p已经是一个指向arr首元素的指针

// 我们可以设法获取数组尾元素之后的那个并不存在的元素的地址：
// int arr[10];
// int *e = &arr[10]; 这里使用下标运算索引了一个尾后的并不存在的元素，这里唯一
// 的作用就是初始化一个数组的尾后指针

/**
 * 只要指针指向的是数组中的元素（或是数组中尾元素的下一位置），都可以执行下标运算：
 * int *p = &ia[2];   p指向索引为2的元素
 * int j = p[1];      p[1]等价于*(p+1)，也就是ia[3]表示的那个元素
 * int k = p[-2];     代表ia[0]的那个元素
 * 虽然标准库类型string和vector也能执行下标运算，但是数组与他们相比还是有所不同。
 * 标准库类型先定使用的下标必须是无符号类型，而内置数组的下标运算五次要求。数组的
 * 下标运算可以处理负值
 **/

/**
 * 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该
 * 是引用类型。因为auto很容易使编译器自动将数组退化为指向数组首元素的指针，这样会
 * 影响到内层的循环，如：
 * for (auto row: ia)
 *     for (auto col: row)
 * 这里row退化为了指向数组首元素的指针，正确的写法应该是 for (auto &row: ia)
 **/

/**
 * int ia[3][4];
 * for (auto p = ia; p != ia+3; ++p)
 *     for (auto q = *p; q != *p+4; ++q)
 * 外层循环先退化成一维数组指针（指向第一个一维数组），p的类型即为 int (*)[4]
 * 内层循环再继续退化，指向每个一维数组的首元素，q的类型即为 int *
 **/





