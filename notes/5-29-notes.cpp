/**
 * 对于string类型的变量来说，它本身接受无参数的初始化方法，所以不论变量
 * 定义在函数内还是在函数外都会被默认初始化为空字符串。但对于内置类型如
 * int来说，如果它被定义在所有函数体之外（如global环境）则默认初始化
 * 为0，否则将不被初始化（如果使用则会遇到一个未定义的奇异值）
 **/

/**
 * 变量声明规定了变量的类型和名字，变量定义也是。但变量定义除此之外还会
 * 申请储存空间，也可能会为变量赋一个初始值
 * 
 * 如果想声明一个变量而非定义它，可以在变量前添加关键字extern，而且不要
 * 显式初始化变量，如
 * extern int i; //声明i而非定义它
 * int j; //声明并定义j
 * extern int i = 10； //extern效果被定义抵消了
 * 如果在函数体内部试图初始化一个由extern标记的变量会报错
 * 
 * 变量能且只能被定义一次，但可以被多次声明。这在C++分离式编译中扮演很
 * 重要的角色。如果要在多个文件中使用同一个变量，就必须将声明和定义分离。
 * 此时变量的定义必须出现且只能出现在一个文件中，而其他用到该变量的文件
 * 必须对其进行声明，却绝对不能重复定义
 **/

// 一个引用一旦确定则无法使其重新绑定到另一个对象
// int a = 10, b = 5;
// int &c = a;
// int &c = b; 报错

// 创造引用时不会进行类型自动转换
// double a = 3.14;
// int &b = a; 报错, 原理是因为在创建
// 引用之前，编译器会首先创建一个int的临时量来存储被narrow的double类型，
// 然后将b绑定为这个临时量的引用。但程序员一般都希望能通过b来修改原a，而
// 此时并不能达到这种目的，故编译器索性判定为非法)
// 同理,
// int *p = &a; 报错

// 任何非0（即非空）指针的条件值都是true
// if (p) 如果p不为空指针则if为真

// 无法直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，如
// int a = 10;
// void *p = &a;
// cout<<*p; 报错
// int *b = p; 报错
// 我们可以利用static_cast来找回存于void*指针中的值，前提是我们要知道指针指
// 向的值的原来的类型，如
// int *b = static_cast<int*>(p);

/**
 * 如果利用一个对象去初始化另一个对象，则它们是不是const都无关紧要，如：
 * int i = 42;
 * const int ci = i; 正确
 * int j = ci; 正确
 * 因为他们做的都是单纯的值拷贝。拷贝了之后新对象和原对象没有任何关系
 **/

// 对于普通引用来说，等式右边必须为一个左值。但对于常量引用来说，等式右边
// 可以为一个左值也可以为一个右值

/**
 * int &a; 非法，普通引用必须被初始化
 * const int &b; 非法，const引用必须被初始化
 * const int i; 非法，const常量必须被初始化
 * int *const p; 非法，const指针必须被初始化
 * const int* p；合法，指向const的指针可以不被初始化
 **/

/**
 * 顶层const：
 * 1. 常量指针即 int *const ptr
 * 2. 普通常量即 const int ci
 * 
 * 底层const：
 * 1. 指向常量的指针即 const int *p (const int *const p)
 * 2. const引用即 const int &a = b
 * 
 * 在拷贝过程中，并不会改变被拷贝对象的值，所以拷入和拷出的对象是否是常量
 * 没有关系。换句话说，顶层const不会影响。但在拷贝的时候，拷入和拷出的对象
 * 必须具有相同的底层const资格，或者是非常量转换为底层const
 **/

/**
 * typedef char *pstring;  pstring是char指针的别名
 * const pstring p = 0; <<==>> char *const p = 0; const修饰指针
 **/

/**
 * auto会忽略顶层const而保留底层const，如
 * const int ci = 10;
 * auto b = ci; b的类型为int，忽略了顶层const
 * auto c = &ci; c的类型为const int*，保留了底层const
 * 可以显性地设置const：
 * const auto d = ci; d的类型为const int
 **/

/**
 * decltype返回变量类型的时候会保留顶层const和引用，如
 * const int ci = 0, &cj = ci;
 * decltype(ci) x = 0;  x的类型是const int
 * decltype(cj) y = x;  y的类型是const int&，是一个引用，将y绑定到x
 **/

// !!! 指针解引之后得到的是引用，是一个左值 ！！！
// int i = 5, *p = &i;
// decltype(*p) c = i;  c的类型是int&而不是单纯的int

// decltype((variable)) (注意是双层括号)的结果永远是引用,
// 而decltype(variable)结果只有当variable本身就是一个引用时才是引用。
// 另外，在赋值的时候常常会产生引用。如
// int a = 3, b = 10;
// decltype(a == b) d = a;  a==b表达式的类型是int&而不是int

/**
 * 当创建类的对象时，类内的初始值将用于初始化数据成员。当数据成员没有初始
 * 值的时候会执行默认初始化，具体初始化的结果根据类型来定。比如string会
 * 自动被初始化为一个空字符串，但int，double等内置类型则会被初始化成一个
 * 奇异值
 **/









